#ifndef _CEU_HTTP
#define _CEU_HTTP

input (int) REQUEST_FINISHED;
native @pure
        _SOUP_SESSION_FEATURE(); 

native @plain
        _SOUP_LOGGER_LOG_BODY,
        _SOUP_MESSAGE_NO_REDIRECT;

native @nohold
        _g_free(),
        _g_main_context_iteration(),
        _g_main_loop_get_context(),
        _g_main_loop_quit(),
        _g_main_loop_unref(),
        _g_object_unref(),
        _printf(),
        _soup_message_new(),
        _soup_message_new_from_uri(),
        _soup_message_set_flags(),
        _soup_session_add_feature(),
        _soup_session_queue_message(),
        _soup_uri_free (), 
        _soup_uri_new (),
        _soup_uri_set_query(),
        _soup_uri_to_string();

native/pre do
	##include <glib.h>
	##include <stdio.h>
	##include <stdlib.h>

  ##include <libsoup/soup.h> 

  static int req_id = 0;
  typedef char * charptr;
end

data QueryParams with
  tag NIL;
or
  tag CONS with
    var _char[128] key;
    var _char[128] value;
    var QueryParams next;
  end
end

native do
  void
  finished (SoupSession *session, SoupMessage *msg, gpointer id)
  {
    ceu_sys_go(&CEU_APP, CEU_IN_REQUEST_FINISHED, id);
  }
end

class HTTPClient with 
  var char[]& uri;
  var char[]& method;
  var bool redirect;
  pool QueryParams[]& query;
  var int& status;
  var char[]& response;
do
  var _SoupSession &?session;
    finalize 
      session = &_soup_session_new ();
    with
      _g_object_unref (&&session!);
    end

#ifdef LOGGER
  var _SoupLogger &?logger;
    finalize
      logger = &_soup_logger_new (_SOUP_LOGGER_LOG_BODY, -1);
    with
      _g_object_unref (&&logger!);
    end

  _soup_session_add_feature (&&session!, 
                             _SOUP_SESSION_FEATURE (&&logger!));
#endif

  var char[] query_string = [] .. "";

  traverse param in &&this.query do
    if param:CONS then 
      query_string = [] .. query_string .. "&".. (_char&&)param:CONS.key 
                                .. "=" .. (_char&&)param:CONS.value; 
      traverse &&param:CONS.next;
    end
  end

  var _SoupURI &?soupURI;
    finalize
      soupURI = &_soup_uri_new (&&uri[0]);
    with
      _soup_uri_free (&&soupURI!);
    end

  if ($query_string > 0) then
    _soup_uri_set_query (&&soupURI!, &&query_string[0]);

    var _charptr&? uristr;
      finalize 
        uristr = &_soup_uri_to_string (&&soupURI!, false); 
      with
        _g_free (&&uristr!);
      end
  end

  var _SoupMessage &?msg;
    finalize
      msg = &_soup_message_new_from_uri ((_char&&)&&method, &&soupURI!);
    with
    end
	
  if (redirect == false) then
    _soup_message_set_flags (&&msg!, _SOUP_MESSAGE_NO_REDIRECT);
  end

  _g_object_ref (&&msg!) 
    finalize with
      _g_object_unref (&&msg!);
    end;

  var int my_req_id = _req_id;
  _req_id = _req_id + 1;

  _soup_session_queue_message (&&session!, &&msg!, _finished, &&my_req_id);

  var int response_to = await REQUEST_FINISHED 
                                      until (response_to == my_req_id);
  var _char&& charptr = &&msg!.response_body:data[0];
  response = [] .. (_char&&)charptr;

  status = msg!.status_code;
end


/***********    async block   *************/
spawn do
  var _GMainLoop &?main_loop;
    finalize
      main_loop = &_g_main_loop_new (null, true);
    with
      _g_main_loop_quit (&&main_loop!);
      _g_main_loop_unref (&&main_loop!);
    end

  var _GMainContext &?context;
    finalize
      context = &_g_main_loop_get_context (&&main_loop!);
    with
    end

  async (context) do 
    var s64 base, current, tmp;
    base = _g_get_monotonic_time ();
    current = 0;
    tmp = 0;

    loop do
      current = _g_get_monotonic_time ();
      tmp = current - base;
      
      base = current;
      emit (tmp)us;
      _g_main_context_iteration (&&context!, false);
    end
  end
  await FOREVER;
end

#endif
