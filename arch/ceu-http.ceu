#ifndef _CEU_HTTP
#define _CEU_HTTP

input (int) REQUEST_FINISHED;
input (int, _gucharptr, _gsize) LOAD_BUFFER_FINISHED;

native @pure
        _SOUP_SESSION_FEATURE(), 
        _UNSAFE();

native @plain
        _SOUP_LOGGER_LOG_BODY,
        _SOUP_MESSAGE_NO_REDIRECT;

native @nohold
        _g_free(),
        _g_main_context_iteration(),
        _g_main_loop_get_context(),
        _g_main_loop_quit(),
        _g_main_loop_unref(),
        _g_object_unref(),
        _g_thread_new (),
        _g_thread_unref(),
        _load_buffer_data_new(),
        _printf(),
        _soup_buffer_free(),
        _soup_form_request_new_from_multipart(),
        _soup_message_new(),
        _soup_message_new_from_uri(),
        _soup_message_set_flags(),
        _soup_multipart_append_form_file(),
        _soup_multipart_free(),
        _soup_multipart_new(),
        _soup_session_add_feature(),
        _soup_session_queue_message(),
        _soup_uri_free (), 
        _soup_uri_new (),
        _soup_uri_set_query(),
        _soup_uri_to_string();

native/pre do
	##include <glib.h>
	##include <stdio.h>
	##include <stdlib.h>

  ##include <libsoup/soup.h> 

  static int req_id = 0;
  typedef char * charptr;
  typedef guchar * gucharptr;

  #define UNSAFE(X) X

  typedef struct _load_buffer_data_t 
  {
    int id;
    const char *filepath;
  } load_buffer_data_t;
end

data QueryParams with
  tag NIL;
or
  tag CONS with
    var _char[128] key;
    var _char[128] value;
    var QueryParams next;
  end
end

native do
  void
  finished (SoupSession *session, SoupMessage *msg, gpointer id)
  {
    ceu_sys_go(&CEU_APP, CEU_IN_REQUEST_FINISHED, id);
  }

  typedef struct _id_buffer_tuple_t
  {
    int id;
    guchar *buffer;
    gsize length;
  } id_buffer_tuple_t;

  load_buffer_data_t *load_buffer_data_new (int id, const char *filepath)
  {
    load_buffer_data_t *data = g_malloc (sizeof (load_buffer_data_t));
    data->id = id;
    data->filepath = filepath;
    return data;
  }

  gpointer load_buffer (gpointer ptr)
  {
    FILE *file = NULL;
    guchar *buffer;
    gsize length;
    load_buffer_data_t *data;
    id_buffer_tuple_t tuple;

    data = (load_buffer_data_t *) ptr;

    file = fopen (data->filepath, "rb");
    if (!file)
    {
      g_printerr ("Could not open %s\n.", data->filepath);
      return NULL;
    }


    fseek (file, 0L, SEEK_END); 
    length = ftell (file);
    rewind (file);

    buffer = g_malloc (length + 1); 
    fread (buffer, sizeof(guchar), length, file);
    fclose (file);

    tuple.id = data->id;
    tuple.buffer = buffer;
    tuple.length = length;

    ceu_sys_go(&CEU_APP, CEU_IN_LOAD_BUFFER_FINISHED, &tuple);

    return NULL;
  }
end

class HTTPClient with 
  var char[]& uri;
  var char[]& method;
  var char[]& mp_data;
  pool QueryParams[]& query;
  var bool redirect;
  var int& status;
  var char[]& response;
do
  var int my_req_id = _req_id;
  _req_id = _req_id + 1;

  var _SoupSession &?session;
    finalize 
      session = &_soup_session_new ();
    with
      _g_object_unref (&&session!);
    end

#ifdef LOGGER
  var _SoupLogger &?logger;
    finalize
      logger = &_soup_logger_new (_SOUP_LOGGER_LOG_BODY, -1);
    with
      _g_object_unref (&&logger!);
    end

  _soup_session_add_feature (&&session!, 
                             _SOUP_SESSION_FEATURE (&&logger!));
#endif

  var char[] query_string = [] .. "";

  traverse param in &&this.query do
    if param:CONS then 
      query_string = [] .. query_string .. "&".. (_char&&)param:CONS.key 
                                .. "=" .. (_char&&)param:CONS.value; 
      traverse &&param:CONS.next;
    end
  end

  var _SoupURI &?soupURI;
    finalize
      soupURI = &_soup_uri_new (&&uri[0]);
    with
      _soup_uri_free (&&soupURI!);
    end

  if ($query_string > 0) then
    _soup_uri_set_query (&&soupURI!, &&query_string[0]);
  end

  var _charptr&? uristr;
    finalize 
      uristr = &_soup_uri_to_string (&&soupURI!, false); 
    with
      _g_free (&&uristr!);
    end

  var _SoupMessage &?msg;
  if ($mp_data > 0) then
    /* par/or do */ 
    /*   async/thread (my_req_id, mp_data) do */ 
    /*     _load_buffer (my_req_id, mp_data!); */
    /*   end */
    /* with */
    /*   var int id; */
    /*   var _gucharptr buff; */
    /*   (id, buff) = await LOAD_BUFFER_FINISHED until (id == my_req_id); */ 
    /* end */
    var _load_buffer_data_t&? arg;
      finalize
        arg = &_load_buffer_data_new (my_req_id, &&mp_data[0]);
      with
        _g_free (&&arg!);
      end

    var _GThread&? worker;
    finalize
      worker = &_g_thread_new (null, _load_buffer, &&arg!);
    with
      _g_thread_unref (&&worker!);
    end
    
    var int id;
    var _gucharptr buff;
    var _gsize length;
    (id, buff, length) = await LOAD_BUFFER_FINISHED 
                                                until (id == my_req_id); 

    var _SoupBuffer &?soup_buffer;
      finalize
        soup_buffer = &_soup_buffer_new_take (buff, length) 
                          finalize with
                          end;
      with
        _soup_buffer_free (&&soup_buffer!);
      end

    var _SoupMultipart &?multipart;
      finalize
        multipart = &_soup_multipart_new ("multipart/form-data");
      with
        _soup_multipart_free (&&multipart!);
      end

    _soup_multipart_append_form_file (&&multipart!, "images_data", 
          &&mp_data[0], "image/jpg", &&soup_buffer!);

    finalize
      msg = &_soup_form_request_new_from_multipart (&&uristr!, &&multipart!);
    with
    end
  else
    finalize
      msg = &_soup_message_new_from_uri ((_char&&)&&method, &&soupURI!);
    with
    end
  end
  if (redirect == false) then
    _soup_message_set_flags (&&msg!, _SOUP_MESSAGE_NO_REDIRECT);
  end

  _g_object_ref (&&msg!) 
    finalize with
      _g_object_unref (&&msg!);
    end;

  _soup_session_queue_message (&&session!, &&msg!, _finished, &&my_req_id);

  var int response_to = await REQUEST_FINISHED 
                                      until (response_to == my_req_id);
  var _char&& charptr = &&msg!.response_body:data[0];
  response = [] .. (_char&&)charptr;

  status = msg!.status_code;
end

/***********    async block   *************/
spawn do
  var _GMainLoop &?main_loop;
    finalize
      main_loop = &_g_main_loop_new (null, true);
    with
      _g_main_loop_quit (&&main_loop!);
      _g_main_loop_unref (&&main_loop!);
    end

  var _GMainContext &?context;
    finalize
      context = &_g_main_loop_get_context (&&main_loop!);
    with
    end

  async (context) do 
    var s64 base, current, tmp;
    base = _g_get_monotonic_time ();
    current = 0;
    tmp = 0;

    loop do
      current = _g_get_monotonic_time ();
      tmp = current - base;
      
      base = current;
      emit (tmp)us;
      _g_main_context_iteration (&&context!, false);
    end
  end
  await FOREVER;
end

#endif
